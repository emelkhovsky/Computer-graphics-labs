#include <QtOpenGL/QGLWidget>
#include "View.h"

View::View() {
}

View::~View(){
}

template <class T>//чтобы не выйти за границы 1
T clamp(T v, int max, int min) {
	if (v > max) {
		return max;
	}
	if (v < min) {
		return min;
	}
	return v;
}

void View::input_layer(int value) {//функция, нужная для смены слоев в позунке
	if (value >= 2) {
		layerNumber = value;
	}
	else {
		layerNumber = 1;
	}

	updateGL();//в любой ф-ии, где что-то перерисовывается, фигачим эту ф-ию
	if (mode == 2) {
		glEnable(GL_TEXTURE_2D);//включаем какую-то возможность gl
		genTextureImage(layerNumber);
		Load2dTexture();
		updateGL();
	}
	else {
		glDisable(GL_TEXTURE_2D);//выключаем какую-то возможность gl
	}
}

void View::setmode(int value) {
	mode = value;
	if (mode == 2) {
		glEnable(GL_TEXTURE_2D);//включаем какую-то возможность gl
		genTextureImage(layerNumber);
		Load2dTexture();
		updateGL();
	}
	else {
		glDisable(GL_TEXTURE_2D);//выключаем какую-то возможность gl
	}
	paintGL();
}

int TransferFunction(short value, int imin, int imax) {//переводит значения плотности томограммы в черно-белый цвет
	int min = imin;
	int max = imax;
	int newVal = (value - min) * 255 / (max - min);
	return newVal;
}

void View::initializeGL() {//инициализация
	glClearColor(0.0f, 0.0f, 0.0f, 1.0f);//очистка буфера изображения
	glGenTextures(1, &VBOtexture);//генерируем уникальный номер текстуры, создаем пространство, где будут все данные, связанные с текстурой
}

void View::resizeGL(int width, int height) {//окно вывода
	glShadeModel(GL_SMOOTH);//с градиентом фигура или нет
	glMatrixMode(GL_PROJECTION);//режим матрицы проекций
	glLoadIdentity();//инициализировали матрицу и сбросили до состояния по умолчанию(единичной???)
	if (slaider_axis == "Z") {
		first = test.X;
		second = test.Y;
	}
	else if (slaider_axis == "X") {
		first = test.Y;
		second = test.Z;
	}
	else {
		first = test.X;
		second = test.Z;
	}
	cout << first << " " << second << endl;
	glOrtho(0, first, 0, second, -1, 1);//установка двумерной ортографической системы координат(тупо проекция картинки)
	glViewport(0, 0, width, height);//задали прямоугольник, через который мы видим эту проекцию
}

void View::paintGL() {//отрисовка четырехугольника
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//очищает буфер цвета и буфер глубины
	switch (mode) {
	case 0://отрисовка четырехугольниками
		DrawQuads(layerNumber);
		break;
	case 1://через 4 точки прямоугольника, а потом добавляем по 2
		DrawQuadStrip();
		break;
	case 2:
		VizualizationTexture();//с текстурами
		break;
	}
}

void View::DrawQuads(int layerNumber) {//отрисовка четырехугольника
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//очищает буфер цвета и буфер глубины
	glBegin(GL_QUADS);//указываем, что будем рисовать прямоугольник
	for (int x_coord = 0; x_coord < first - 1; x_coord++) {
		for (int y_coord = 0; y_coord < second - 1; y_coord++) {
			short value;
			int transfer;
			//1 вершина
			value = test.array[x_coord + y_coord * first + layerNumber * first * second];//находим значение
			transfer = TransferFunction(value, min, max);
			glColor3f(transfer, transfer, transfer);//задаем цвет
			glVertex2i(x_coord, y_coord);//указываем вершину
			//2 вершина
			value = test.array[x_coord + (y_coord + 1) * first + layerNumber * first * second];
			transfer = TransferFunction(value, min, max);
			glColor3f(transfer, transfer, transfer);
			glVertex2i(x_coord, (y_coord + 1));
			//3 вершина
			value = test.array[(x_coord + 1) + (y_coord + 1) * first + layerNumber * first * second];
			transfer = TransferFunction(value, min, max);
			glColor3f(transfer, transfer, transfer);
			glVertex2i((x_coord + 1), (y_coord + 1));
			//4 вершина
			value = test.array[(x_coord + 1) + y_coord * first + layerNumber * first * second];
			transfer = TransferFunction(value, min, max);
			glColor3f(transfer, transfer, transfer);
			glVertex2i((x_coord + 1), y_coord);
		}
	}
	glEnd();//закончили рисовать
}



void View::Load2dTexture() {//загрузка текстуры в память видеокарты
	glBindTexture(GL_TEXTURE_2D, VBOtexture);//привязываем текстуру к определенному текстурному типу
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, textureImage.width(), textureImage.height(), 0, GL_BGRA, GL_UNSIGNED_BYTE, textureImage.bits());//загружаем текстуру в память видеокарты(какая текстурка, базовый уровень детализации?, формат(цветовой) текстуры, ширина, высота, граница, формат(цветовой) пикселей, тип пикселей, данные)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);//устанавливаем параметры для текущей текстуры, привязанной к текстурному блоку
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//какая текстура, масштабирование при изменении размера окна(вроде), алгоритм фильтрациии(крч похоже на размытие)
}

void View::genTextureImage(int layerNumber) {//отрисовка текстурированного прямоугольника
	int w = first;
	int h = second;
	textureImage = QImage(w, h, QImage::Format_RGB32);
	for (int y = 0; y < h; y++) {
		for (int x = 0; x < w; x++) {
			int intensity = TransferFunction(test.array[layerNumber * w * h + w * y + x], min, max);
			QColor c = QColor::fromRgbF(intensity, intensity, intensity);
			textureImage.setPixelColor(x, y, c);
		}
	}
}

void View::VizualizationTexture() {//рисуем один прямоугольник с наложенной текстурой
	glBegin(GL_QUADS);
	qglColor(QColor(255, 255, 255));

	glTexCoord2f(0, 0);
	glVertex2i(0, 0);

	glTexCoord2f(0, 1);
	glVertex2i(0, second);

	glTexCoord2f(1, 1);
	glVertex2i(first, second);

	glTexCoord2f(1, 0);
	glVertex2i(first, 0);

	glEnd();
}


void View::DrawQuadStrip() {
	short value;
	int transfer;
	for (int y_coord = 0; y_coord < second - 1; y_coord++){
		for (int x_coord = 0; x_coord < first; x_coord++){

				glBegin(GL_QUAD_STRIP);
				
				value = test.array[x_coord + y_coord * first + layerNumber * first * second];//находим значение
				transfer = TransferFunction(value, min, max);
				glColor3f(transfer, transfer, transfer);//задаем цвет
				glVertex2i(x_coord, y_coord);//указываем вершину
				//2 вершина
				value = test.array[x_coord + (y_coord + 1) * first + layerNumber * first * second];
				transfer = TransferFunction(value, min, max);
				glColor3f(transfer, transfer, transfer);
				glVertex2i(x_coord, (y_coord + 1));
				//3 вершина
				value = test.array[(x_coord + 1) + (y_coord + 1) * first + layerNumber * first * second];
				transfer = TransferFunction(value, min, max);
				glColor3f(transfer, transfer, transfer);
				glVertex2i((x_coord + 1), (y_coord + 1));
				//4 вершина
				value = test.array[(x_coord + 1) + y_coord * first + layerNumber * first * second];
				transfer = TransferFunction(value, min, max);
				glColor3f(transfer, transfer, transfer);
				glVertex2i((x_coord + 1), y_coord);

				glEnd();
		}
	}
}

